## 🤖 AIエージェントの要件定義

LangGraphを用いて構築される3つのAIエージェントのシステムについて、必要な要件と処理内容を定義します。

-----

### 1\. 司令塔エージェント (Orchestrator Agent)

#### 役割

ユーザーからのインプットを受け取り、処理に必要な\*\*タグ（技術キーワード）\*\*を抽出し、その後のエージェントの処理フローを制御する役割を担います。

#### 処理要件

  * **インプットの解釈:** ユーザーの要求（例：「ReactとNext.jsの学習ロードマップを作成したい」）を解釈し、処理のトリガーとします。
  * **タグの抽出:** インプットから、調査対象となる**技術キーワードのリスト**（例：`["React", "Next.js", "TypeScript"]`）を正確に抽出します。
  * **フローの開始:** 抽出した技術キーワードのリストを、次の**技術調査エージェント**へ渡して処理を開始します。
  * **LangGraphにおける役割:** 処理の**開始ノード**および、技術調査結果をロードマップ作成エージェントへ橋渡しする**遷移制御ノード**として機能します。

#### 受け入れ条件

  * ユーザーの要求文から、意図された技術タグを**95%以上の精度**で抽出できること。
  * 処理を続行するためのタグリストを、次のエージェントが利用できる形式（例：Pythonのリスト）で出力できること。

-----

### 2\. 技術調査エージェント (Technical Research Agent)

#### 役割

司令塔エージェントから受け取った技術タグに基づき、**Tavily**検索ツールを使用して、各技術の概要、要約、および関連リンクを取得します。

#### 処理要件

  * **インプットの受信:** 司令塔エージェントから**技術タグのリスト**を受け取ります。
  * **並列/逐次検索:** リスト内の**各技術タグごと**に、Tavily APIを使用してWeb検索を実行します。
  * **情報収集:** 検索結果から、以下の情報を抽出・整理します。
      * **技術の要約（Summary）:** その技術が何であるか、主要な特徴は何かをまとめた簡潔な説明。
      * **参考リンク（Links）:** 詳細な情報やチュートリアルが期待できる、信頼性の高いWebページのURLリスト。
  * **コンテキストの形成:** 全ての技術に関する収集結果を統合し、次のエージェントが利用しやすい**コンテキストデータ構造**（例：タグ名、要約、リンクを含む辞書のリスト）を形成します。

#### 受け入れ条件

  * Tavily検索を確実に実行し、**タイムアウトせずに**結果を返せること。
  * 収集された要約が、技術の本質を**80%以上の正確性**で捉えていること。
  * 出力されたコンテキストデータ構造が、**ロードマップ作成エージェントの入力スキーマと完全に一致**していること。

-----

### 3\. 学習ロードマップ作成エージェント (Learning Roadmap Generation Agent)

#### 役割

技術調査エージェントから提供されたコンテキストデータに基づき、学習ロードマップを**JSON構造**で出力します。これがシステムの最終的なアウトプットとなります。

#### 処理要件

  * **インプットの受信:** 技術調査エージェントから、**調査済みの技術コンテキストデータ**を受け取ります。
  * **ロードマップの生成:** 以下の要素を含む学習ロードマップを、ステップバイステップで構成します。
      * **学習カテゴリ/フェーズ:**（例：`基礎`, `応用`, `実践`）
      * **学習タスク/トピック:**（例：`React Componentの理解`, `Next.jsでのルーティング実装`）
      * **所要時間（目安）:** 各タスクに必要な時間の見積もり。
      * **参考資料:** 調査エージェントから提供された関連リンク。
  * **JSON構造の出力:** 生成したロードマップを、事前に定義された**スキーマに厳密に従ったJSON形式**で最終出力します。

#### JSON出力スキーマの例

```json
{
  "roadmapTitle": "技術名_学習ロードマップ",
  "technologies": [
    {
      "name": "技術名",
      "summary": "調査結果の要約",
      "phases": [
        {
          "phaseName": "フェーズ名 (例: 基礎)",
          "order": 1,
          "steps": [
            {
              "topic": "学習トピック (例: 環境構築)",
              "estimatedTime": "時間 (例: 4h)",
              "sourceLinks": [
                {"title": "リンク名", "url": "URL"}
              ]
            }
          ]
        }
      ]
    }
  ]
}
```

#### 受け入れ条件

  * 出力が、定義された**JSONスキーマに完全に準拠**し、構文エラーがないこと。
  * JSON内のロードマップが、提供された**コンテキストデータと論理的に一貫性**があり、学習順序が妥当であること。
  * 最終出力として、整形された**JSONテキストのみ**を返すこと。

-----

### ⚙️ LangGraphの処理フロー (State and Edges)

LangGraphでは、以下の**状態**と\*\*遷移（エッジ）\*\*で上記の要件を実現します。

| No. | ノード（エージェント） | State Key (状態変数) | 遷移（エッジ） |
| :---: | :--- | :--- | :--- |
| **1** | **司令塔エージェント** | `tags`: 抽出された技術タグリスト | 1. 成功 $\rightarrow$ **技術調査エージェント** |
| **2** | **技術調査エージェント** | `context`: 調査結果を含むコンテキストデータ | 1. 成功 $\rightarrow$ **ロードマップ作成エージェント** |
| **3** | **ロードマップ作成エージェント** | `roadmap_json`: 最終的なJSON出力 | 1. 成功 $\rightarrow$ **FINISH** (終了) |

-----

これで、LangGraphを用いたエージェントシステムの各構成要素の役割、処理要件、および受け入れ条件が明確になりました。

この要件定義に基づいて、各エージェントのプロンプト設計やLangGraphの状態（State）の具体的な構造定義に進みますか？
